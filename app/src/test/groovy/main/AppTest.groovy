/*
 * This Spock specification was generated by the Gradle 'init' task.
 */
package main

import spock.lang.Specification

class AppTest extends Specification {
    def "calculate correct id"(){
        setup:
        Map b = new Map(2,3)

        when:
            def r1 = b.convertIndexToCoord(0)
            def r2 = b.convertIndexToCoord(1)
            def r3 = b.convertIndexToCoord(2)
            def r4 = b.convertIndexToCoord(3)
            def r5 = b.convertIndexToCoord(4)
            def r6 = b.convertIndexToCoord(5)
        then:
            r1 == new TileId(0,0) &&
            r2 == new TileId(1,0) &&
            r3 == new TileId(0,1) &&
            r4 == new TileId(1,1) &&
            r5 == new TileId(0,2) &&
            r6 == new TileId(1,2) 
    }

    def "getAt works"(){
        setup:
        Map b = new Map(2,3)

        when:
            def result = b.getAt(new TileId(0, 0))
        then:
            result.id == new TileId(0,0)
    }

    def "TileId equals works"(){
        setup:
            TileId id1 = new TileId(1,0)
            TileId id2 = new TileId(1,0)
            TileId id3 = new TileId(0,0)

        when:
            def r1 = id1 == id2
            def r2 = id2 == id3
        then:
            r1 && !r2
    }

    def "getNeighbours worls"(){
        setup:
            def map = new Map(3,3)
        
        when:
            def middleN = map.getNeighbours(new TileId(1,1))
            def upperCorner = map.getNeighbours(new TileId(0,0))
        
        then:
            middleN == [
                new Tuple2(new TileId(0,1), Orientation.LEFT),
                new Tuple2(new TileId(1,0), Orientation.TOP),
                new Tuple2(new TileId(2,1), Orientation.RIGHT),
                new Tuple2(new TileId(1,2), Orientation.BOTTOM)
            ]
            &&
            upperCorner == [
                new Tuple2(new TileId(1,0), Orientation.RIGHT),
                new Tuple2(new TileId(0,1), Orientation.BOTTOM),
            ]
    }

    def "Rule application works"(){
        setup:
            def r = new Rule(TileType.SAND, TileType.SAND, Orientation.LEFT)

        when:
            def result = r.apply(TileType.SAND, TileType.SAND, Orientation.LEFT)
            def result2 = r.apply(TileType.SAND, TileType.FOREST, Orientation.LEFT)
        
        then:
            result == [TileType.SAND] as Set 
            result2 == [] as Set
    }

    def "Tile update works correctly"(){
        setup:
            def t1 = new Tile(0,0)
            def t2 = new Tile(0,1)
            def t3 = new Tile(0,2)
            def rg = new RuleSetGenerator()
            Rule[] ALL_TILES_ALLOWED = 
                rg.allowAllOrientations(TileType.SAND, TileType.SAND) +
                rg.allowAllOrientations(TileType.WATER, TileType.WATER) +
                rg.allowAllOrientations(TileType.FOREST, TileType.FOREST) +
                rg.allowAllOrientations(TileType.STONE, TileType.STONE) +
                rg.allowAllOrientations(TileType.MOUNTAIN_TOP, TileType.MOUNTAIN_TOP) +
                rg.allowAllOrientations(TileType.MOUNTAIN_BOTTOM, TileType.MOUNTAIN_BOTTOM)
        
        when:
            t1.collapse()
            t2.update(t1, Orientation.RIGHT, ALL_TILES_ALLOWED)
            t3.update(t2, Orientation.RIGHT, ALL_TILES_ALLOWED)
        
        then:
            t2.entropy() == 1 && t3.entropy() == 1
    }
}
